# LeetCode 1498. Number of Subsequences That Satisfy the Given Sum Condition

難度：Medium
連結：[LeetCode 題目連結](https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/)

---

## 題目說明
    
class Solution {
public:
    int numSubseq(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int result = 0, n = nums.size(), l = 0, r = n - 1, mod = 1e9 + 7;
        
        vector<int> pows(n, 1);
        for (int i = 1; i < n; i++) {
            pows[i] = (pows[i-1] * 2) % mod;
        }

        while (l <= r) {
            if (nums[l] + nums[r] <= target) {
                result = (result + pows[r - l]) % mod;
                l++;
            }
            else {
                r--;
            }
        }

        return result;
    }
};

## 解法
### 1. Binary Search
#### 思路

這題subsequence是找最大和最小的sum小於等於target的數量，因此順序並非重點，可以先sort過。

接著用binary search來做，當l和r的區間中，最大和最小的sum小於等於target的數量，就累加

#### 代碼
```c++
/*
    nums = [1,2,3,5,6,7], target = 9
    pows = {1, 2, 4, 8, 16, 32}
    1. nums[l] = 1, nums[r] = 7, nums[l] + nums[r] = 8 <= 9 (result = 0 + 32 = 32)      // 2,3,5,6,7任選
    2. nums[l] = 2, nums[r] = 7, nums[l] + nums[r] = 9 == 9 (result = 32 + 16 = 32)     // 上次的加這次3,5,6,7任選
    ...
*/
class Solution {
public:
    int numSubseq(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int result = 0, n = nums.size(), l = 0, r = n - 1, mod = 1e9 + 7;
        
        vector<int> pows(n, 1);
        for (int i = 1; i < n; i++) {
            pows[i] = (pows[i-1] * 2) % mod;
        }

        while (l <= r) {
            if (nums[l] + nums[r] <= target) {
                result = (result + pows[r - l]) % mod;
                l++;
            }
            else {
                r--;
            }
        }

        return result;
    }
};
```

#### 複雜度分析

- 時間複雜度：O(nlogn)
- 空間複雜度：O(n)